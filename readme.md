# 算法的时间复杂度表示法
## 大O复杂度表示法
大O时间复杂度并不是具体表示代码真正的执行时间，
而是表示代码执行时间岁数据规模增长的变化趋势，
所以也叫做**渐进时间复杂度**，简称**时间复杂度**。

### O(1)
一般情况下，只要算法中不存在循环语句，递归语句，即使有成千上万行代码，其时间复杂度也是O（1）

### O(logn) O(nlogn)
```java
i = 1
while( i <= n) {  // 循环n次
    i = i * 2;    // log2n的复杂度
}
```
第三行代码是循环次数最多的， 所以只需要计算此行代码被执行了多少次，就能知道整段代码的时间复杂度。
总体复杂度位 nlogn,归并排序快速排序的时间复杂度。

# 递归问题的解题步骤
1. 找整个递归的终止条件：递归应该在什么时候结束？
2. 找返回值：应该给上一级返回什么信息？
3. 本级递归应该做什么：在这一级递归中，应该完成什么任务？

**例题1：求二叉树的最大深度**
1. 找终止条件。 什么情况下递归结束？当然是树为空的时候，此时树的深度为0，递归就结束了。
2. 找返回值。 应该返回什么？题目求的是树的最大深度，我们需要从每一级得到的信息自然是当前这一级对应的树的最大深度，因此我们的返回值应该是当前树的最大深度，这一步可以结合第三步来看。
3. 本级递归应该做什么。 首先，还是强调要走出之前的思维误区，递归后我们眼里的树一定是这个样子的，看下图。此时就三个节点：root、root.left、root.right，其中根据第二步，root.left和root.right分别记录的是root的左右子树的最大深度。那么本级递归应该做什么就很明确了，自然就是在root的左右子树中选择较大的一个，再加上1就是以root为根的子树的最大深度了，然后再返回这个深度即可。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        //终止条件：当树为空时结束递归，并返回当前深度0
        if(root == null){
            return 0;
        }
        //root的左、右子树的最大深度
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        //返回的是左右子树的最大深度+1
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

**例题2：两两交换链表中的节点**
1. 找终止条件。 什么情况下递归终止？没得交换的时候，递归就终止了呗。因此当链表只剩一个节点或者没有节点的时候，自然递归就终止了。
2. 找返回值。 我们希望向上一级递归返回什么信息？由于我们的目的是两两交换链表中相邻的节点，因此自然希望交换给上一级递归的是已经完成交换处理，即已经处理好的链表。
3. 本级递归应该做什么。 结合第二步，看下图！由于只考虑本级递归，所以这个链表在我们眼里其实也就三个节点：head、head.next、已处理完的链表部分。而本级递归的任务也就是交换这3个节点中的前两个节点，就很easy了。
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
      	//终止条件：链表只剩一个节点或者没节点了，没得交换了。返回的是已经处理好的链表
        if(head == null || head.next == null){
            return head;
        }
      	//一共三个节点:head, next, swapPairs(next.next)
      	//下面的任务便是交换这3个节点中的前两个节点
        ListNode next = head.next;
        head.next = swapPairs(next.next);
        next.next = head;
      	//根据第二步：返回给上一级的是当前已经完成交换后，即处理好了的链表部分
        return next;
    }
}
```
